<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¶“å…¸è²ªåƒè›‡ Â· è¶…ç´šå¤§æ ¼å­ Â· è˜‹æœä¸é è§’</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            margin: 0;
            min-height: 100vh;
            background: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }
        .game-container {
            background: #ffffff;
            padding: 25px 30px 30px;
            border-radius: 48px 48px 36px 36px;
            box-shadow: 0 20px 30px rgba(0,0,0,0.15), inset 0 0 0 2px #dddddd;
        }
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: #3a5e4c;
            padding: 0 8px 12px 8px;
            font-weight: 600;
        }
        .score-box {
            background: #f5f5f5;
            padding: 8px 24px;
            border-radius: 60px;
            font-size: 1.7rem;
            letter-spacing: 2px;
            color: #1f4d3a;
            box-shadow: inset 0 -3px 0 #c0c0c0, inset 0 2px 8px #e0e0e0;
            border-bottom: 2px solid #b0b0b0;
            font-weight: 700;
        }
        .restart-btn {
            background: #d6ae7a;
            border: none;
            color: #2b4a3c;
            font-size: 1.2rem;
            font-weight: bold;
            padding: 8px 28px;
            border-radius: 40px;
            cursor: pointer;
            box-shadow: 0 6px 0 #ac8e62, 0 8px 12px rgba(0,0,0,0.15);
            transition: all 0.07s ease;
            letter-spacing: 1px;
            border: 1px solid #efd39c;
        }
        .restart-btn:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #ac8e62, 0 5px 10px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 32px;
            background-color: #ffffff;
            box-shadow: inset 0 0 0 3px #cccccc, 0 16px 28px rgba(0,0,0,0.1);
            width: 500px;        /* ç¶­æŒåŸæœ¬ 500x500 */
            height: 500px;
            image-rendering: crisp-edges;
        }
        .control-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            color: #3d5e4e;
            padding: 0 12px;
        }
        .hint {
            display: flex;
            gap: 16px;
            background: #f5f5f5;
            padding: 8px 22px;
            border-radius: 40px;
            border: 1px solid #b0b0b0;
            box-shadow: inset 0 1px 4px #d0d0d0;
        }
        .hint kbd {
            background: #e0e0e0;
            color: #2a4a3a;
            padding: 4px 12px;
            border-radius: 30px;
            font-size: 1.3rem;
            font-weight: bold;
            box-shadow: 0 3px 0 #b0b0b0;
        }
        .status {
            background: #fafafa;
            padding: 8px 30px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: 500;
            border: 1px solid #aaaaaa;
            color: #2f4f3f;
        }
        .footer-note {
            text-align: center;
            margin-top: 18px;
            color: #7f8f89;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
<div class="game-container">
    <div class="header">
        <div class="score-box">ğŸ <span id="scoreDisplay">0</span></div>
        <button class="restart-btn" id="restartButton">â‡† æ–°å±€</button>
    </div>

    <canvas id="gameCanvas" width="500" height="500"></canvas>  <!-- ç•«å¸ƒç¶­æŒ 500x500ï¼Œä½†æ ¼å­è®Šå¤§ -->

    <div class="control-panel">
        <div class="hint">
            <kbd>â†</kbd><kbd>â†‘</kbd><kbd>â†“</kbd><kbd>â†’</kbd>
        </div>
        <div class="status" id="gameStatus">â–¶ é€²è¡Œä¸­</div>
    </div>
    <div class="footer-note">
        âš¡ æ¯åƒä¸€é¡†é£Ÿç‰© ğŸ é•·åº¦+1 Â· 15x15 ç‰¹å¤§æ ¼å­ Â· è˜‹æœä¸å¡è§’è½
    </div>
</div>

<script>
    (function(){
        // ---------- å›ºå®šåƒæ•¸ ----------
        const GRID_SIZE = 15;               // å¾ 20 æ”¹ç‚º 15ï¼Œæ ¼å­ç«‹åˆ»è®Šå¤§ï¼
        const CELL_SIZE = 500 / GRID_SIZE;  // 500/15 â‰ˆ 33.33px (åŸæœ¬25pxï¼Œç¾åœ¨æ›´å¤§)
        const TICK_INTERVAL_MS = 150;

        // ---------- éŠæˆ²ç‹€æ…‹ ----------
        let snake = [];
        let food = { x: 7, y: 7 };          // åˆå§‹ä½ç½®èª¿æ•´ä¸€ä¸‹
        let direction = 'RIGHT';
        let nextDirection = 'RIGHT';
        let score = 0;
        let gameActive = false;
        let gameOverFlag = false;
        let gameInterval = null;

        // DOM å…ƒç´ 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreSpan = document.getElementById('scoreDisplay');
        const gameStatusDiv = document.getElementById('gameStatus');
        const restartBtn = document.getElementById('restartButton');

        // ---------- åˆå§‹åŒ– / é‡ç½® (è›‡çš„åˆå§‹ä½ç½®ä¹Ÿè¦é…åˆ15x15) ----------
        function resetGame() {
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }

            // åˆå§‹è›‡ï¼šæ°´å¹³æ”¾åœ¨ä¸­é–“åå·¦ (15æ ¼å¯¬)
            snake = [
                [7, 7],   // é ­
                [6, 7],
                [5, 7],
                [4, 7]    // å°¾
            ];
            direction = 'RIGHT';
            nextDirection = 'RIGHT';
            score = 0;
            gameActive = true;
            gameOverFlag = false;

            generateRandomFood();   // æ”¹è‰¯ç‰ˆï¼šé¿é–‹è§’è½ (è§’è½å®šç¾©: x=0,y=0; x=0,y=14; x=14,y=0; x=14,y=14)

            updateScore();
            gameStatusDiv.innerText = 'â–¶ é€²è¡Œä¸­';
            drawCanvas();

            if (!gameInterval) {
                gameInterval = setInterval(gameTick, TICK_INTERVAL_MS);
            }
        }

        // ---------- ç”¢ç”Ÿä¸èˆ‡è›‡é‡ç–Šçš„é£Ÿç‰©ï¼Œä¸”é¿å…è§’è½ (0,0), (0,14), (14,0), (14,14) ----------
        function generateRandomFood() {
            const maxAttempts = 3000;
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const randX = Math.floor(Math.random() * GRID_SIZE);
                const randY = Math.floor(Math.random() * GRID_SIZE);
                
                // æ’é™¤å››å€‹è§’è½ (é‚Šç•Œç´¢å¼• 0 å’Œ 14)
                const isCorner = (randX === 0 && randY === 0) ||
                                 (randX === 0 && randY === GRID_SIZE-1) ||
                                 (randX === GRID_SIZE-1 && randY === 0) ||
                                 (randX === GRID_SIZE-1 && randY === GRID_SIZE-1);
                if (isCorner) continue;  // è§’è½è·³é

                if (!snake.some(segment => segment[0] === randX && segment[1] === randY)) {
                    food = { x: randX, y: randY };
                    return;
                }
            }

            // å¾Œå‚™æƒæï¼šé¿é–‹è›‡èº« + é¿é–‹è§’è½
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const isCorner = (x === 0 && y === 0) || (x === 0 && y === GRID_SIZE-1) ||
                                     (x === GRID_SIZE-1 && y === 0) || (x === GRID_SIZE-1 && y === GRID_SIZE-1);
                    if (isCorner) continue;
                    if (!snake.some(seg => seg[0] === x && seg[1] === y)) {
                        food = { x, y };
                        return;
                    }
                }
            }

            // å¦‚æœçœŸçš„åªå‰©ä¸‹è§’è½æœ‰ç©ºä½ (æ¥µç«¯æƒ…æ³ï¼Œä½†éŠæˆ²ç¹¼çºŒ)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (!snake.some(seg => seg[0] === x && seg[1] === y)) {
                        food = { x, y };
                        return;
                    }
                }
            }
            food = { x: 5, y: 5 };
        }

        function updateScore() {
            scoreSpan.innerText = score;
        }

        // ---------- ç¹ªåœ– (æ ¼å­è®Šå¤§ï¼Œè˜‹æœåŒæ­¥æ”¾å¤§) ----------
        function drawCanvas() {
            ctx.clearRect(0, 0, 500, 500);

            // ç¹ªè£½ç¶²æ ¼ç·š (é…åˆå¤§æ ¼å­ç¨å¾®åŠ ç²—)
            ctx.strokeStyle = '#bbbbbb';
            ctx.lineWidth = 1.5;
            for (let i = 0; i <= GRID_SIZE; i++) {
                const pos = i * CELL_SIZE;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, canvas.height);
                ctx.stroke();
                ctx.moveTo(0, pos);
                ctx.lineTo(canvas.width, pos);
                ctx.stroke();
            }

            // ç¹ªè£½è›‡èº« (å› ç‚ºæ ¼å­è®Šå¤§ï¼Œå…§éƒ¨ç¹ªåœ–åº§æ¨™ä¹Ÿç­‰æ¯”æ”¾å¤§)
            snake.forEach((segment, index) => {
                const [x, y] = segment;
                const isHead = (index === 0);
                
                if (isHead) {
                    ctx.fillStyle = '#e6b450';  // é‡‘è‰²é ­
                } else {
                    const greenValue = 90 + (index % 5) * 15;
                    ctx.fillStyle = `rgb(30, ${greenValue}, 45)`;
                }
                // ç•™å‡ºç´„2pxé–“éš™ï¼Œè®“ç¶²æ ¼ç·šå¯è¦‹
                ctx.fillRect(x * CELL_SIZE + 2, y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                // é ­éƒ¨çœ¼ç› (é…åˆæ”¾å¤§åº§æ¨™ï¼ŒCELL_SIZE â‰ˆ 33.33)
                if (isHead) {
                    ctx.fillStyle = '#222222';
                    const eyeSize = 7;        // çœ¼ç›ç¨å¾®æ”¾å¤§
                    const baseX = x * CELL_SIZE;
                    const baseY = y * CELL_SIZE;
                    if (direction === 'RIGHT') {
                        ctx.fillRect(baseX + 20, baseY + 7, eyeSize, eyeSize);
                        ctx.fillRect(baseX + 20, baseY + 20, eyeSize, eyeSize);
                    } else if (direction === 'LEFT') {
                        ctx.fillRect(baseX + 6, baseY + 7, eyeSize, eyeSize);
                        ctx.fillRect(baseX + 6, baseY + 20, eyeSize, eyeSize);
                    } else if (direction === 'UP') {
                        ctx.fillRect(baseX + 7, baseY + 6, eyeSize, eyeSize);
                        ctx.fillRect(baseX + 20, baseY + 6, eyeSize, eyeSize);
                    } else if (direction === 'DOWN') {
                        ctx.fillRect(baseX + 7, baseY + 21, eyeSize, eyeSize);
                        ctx.fillRect(baseX + 20, baseY + 21, eyeSize, eyeSize);
                    } else {
                        ctx.fillRect(baseX + 20, baseY + 7, 7, 7);
                        ctx.fillRect(baseX + 20, baseY + 20, 7, 7);
                    }
                } else {
                    // èº«é«”å…‰é» (ä½ç½®é…åˆæ”¾å¤§)
                    ctx.fillStyle = '#b3e0c0';
                    ctx.beginPath();
                    ctx.arc(x * CELL_SIZE + CELL_SIZE/2, y * CELL_SIZE + CELL_SIZE/2, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#60a080';
                    ctx.fill();
                }
            });

            // ---------- ç¹ªè£½è˜‹æœ (è¶…å¤§ï¼) ----------
            ctx.shadowColor = '#ccaa88';
            ctx.shadowBlur = 10;
            // è˜‹æœä¸»é«”åŠå¾‘ 15px (å› ç‚ºCELL_SIZEè®Šå¤§ç´„33ï¼Œè˜‹æœå¯ä»¥æ›´å¤§)
            ctx.beginPath();
            ctx.arc(food.x * CELL_SIZE + CELL_SIZE/2, food.y * CELL_SIZE + CELL_SIZE/2, 15, 0, 2 * Math.PI);
            ctx.fillStyle = '#e05555';
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
            
            // è‘‰å­
            ctx.fillStyle = '#7fc45a';
            ctx.beginPath();
            ctx.ellipse(food.x * CELL_SIZE + 12, food.y * CELL_SIZE + 10, 6, 9, 0.2, 0, 2 * Math.PI);
            ctx.fill();
            // äº®é»
            ctx.fillStyle = '#f8ffc4';
            ctx.beginPath();
            ctx.arc(food.x * CELL_SIZE + 22, food.y * CELL_SIZE + 21, 4, 0, 2 * Math.PI);
            ctx.fill();

            // éŠæˆ²çµæŸç–Šå±¤
            if (!gameActive) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.fillRect(0, 0, 500, 500);
                ctx.font = 'bold 32px "Segoe UI", monospace';
                ctx.fillStyle = '#3a4d3a';
                ctx.shadowColor = '#cccccc';
                ctx.shadowBlur = 12;
                ctx.fillText(gameOverFlag ? 'â˜  éŠæˆ²çµæŸ' : 'â¸ æš«åœ', 120, 260);
                ctx.shadowBlur = 0;
            }
        }

        // ---------- ç§»å‹•é‚è¼¯ (èˆ‡ä¹‹å‰ç›¸åŒï¼Œä½†é…åˆGRID_SIZE=15) ----------
        function moveSnake() {
            if (!gameActive) return false;

            const opposite = {
                'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT'
            };
            if (nextDirection && opposite[nextDirection] !== direction) {
                direction = nextDirection;
            }

            const head = snake[0];
            let newHeadX = head[0];
            let newHeadY = head[1];

            switch (direction) {
                case 'RIGHT': newHeadX++; break;
                case 'LEFT':  newHeadX--; break;
                case 'UP':    newHeadY--; break;
                case 'DOWN':  newHeadY++; break;
                default: return false;
            }

            const willEatFood = (newHeadX === food.x && newHeadY === food.y);
            let newSnake = [[newHeadX, newHeadY], ...snake];

            if (willEatFood) {
                snake = newSnake;
                score++;
                updateScore();
                generateRandomFood();
            } else {
                newSnake.pop();
                snake = newSnake;
            }

            const headPos = snake[0];
            if (headPos[0] < 0 || headPos[0] >= GRID_SIZE || headPos[1] < 0 || headPos[1] >= GRID_SIZE) {
                gameActive = false;
                gameOverFlag = true;
                gameStatusDiv.innerText = 'â›” æ’ç‰†äº†';
                stopGame();
                return false;
            }

            for (let i = 1; i < snake.length; i++) {
                if (snake[i][0] === headPos[0] && snake[i][1] === headPos[1]) {
                    gameActive = false;
                    gameOverFlag = true;
                    gameStatusDiv.innerText = 'ğŸ’¥ å’¬åˆ°è‡ªå·±';
                    stopGame();
                    return false;
            }
        }
            return true;
        }

        function stopGame() {
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            gameActive = false;
            drawCanvas();
        }

        function gameTick() {
            if (!gameActive) {
                if (gameInterval) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                }
                return;
            }
            moveSnake();
            drawCanvas();
        }

        // ---------- éµç›¤æ§åˆ¶ ----------
        function handleKeyDown(e) {
            const key = e.key;
            const keyMap = {
                'ArrowUp': 'UP',
                'ArrowDown': 'DOWN',
                'ArrowLeft': 'LEFT',
                'ArrowRight': 'RIGHT'
            };
            if (!(key in keyMap)) return;
            e.preventDefault();
            if (!gameActive) return;

            const requestedDir = keyMap[key];
            const opposite = {
                'UP': 'DOWN', 'DOWN': 'UP', 'LEFT': 'RIGHT', 'RIGHT': 'LEFT'
            };
            if (opposite[requestedDir] !== direction) {
                nextDirection = requestedDir;
            }
        }

        restartBtn.addEventListener('click', resetGame);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', (e) => {
            if (e.key.startsWith('Arrow')) e.preventDefault();
        });

        // å•Ÿå‹•
        resetGame();
    })();
</script>
</body>
</html>